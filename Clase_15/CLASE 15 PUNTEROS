CLASE 15 PUNTEROS

NO SE PUEDE DECLARAR INT *A Y DESPUES UN INT A....OJOOOOOOOOOO!!!

NULL NADA, = NO ES NINGUNA POSICION DE MEMORIA DE LA PC, ES X SI EL PUNTERO NO TIENE ASIGNADO UNA DIRECCION DE MEMORIA...

SE COMIENZA A TRABAJAR CON MEMORIA DINAMICA...Y NO ESTATICA... C TE PERMITE MANIPULAR LA MEMORIA!!!

EL PELIGRO CON EL PUNTERO ES Q SI NO ESTA ASIGNADO EL PUNTERO SOLO PUEDE GUARDAR UN DATO UNA DIRECCION DE MEMORIA QUE QUEDO GUARDADO COMO BASURA Y TE GENERA POSIBLES DESTRUCCIONES DEL PROGRAMA...X LO Q NO SE PUEDE ASIGNAR DE MANERA DIRECTA ASI *PTRONRO=  (A TAL COSA....);   
OJOOO EL PUNTERO NO SE INICIALIZA...

PARA SOLUCIONAR ESO PTRNRO=NULL.....SIN EL ASTERISCO GUARDA LA DIRECCION DE MEMORIA, CON EL * ES INDIRECCION...LE TENES Q PONER EL NUMERO DE TIPO DE DATO PERO WARDA CON EL PROBLEMA ANTERIOR...

SE SOLUCIONA PTRONRTO= &NRO LE ASIGNAS AL PUNTERO LA DIRECCION DE MEMORIA DE NRO Y NO UNA Q PODIA ESTAR EN LA BASURA

DSP *PTRNRO=15; PARA ASIGNARLE A DICHA DIRECCION DE MEMORIA EL VALOR...

SE AGREGA UN TIPO VOID  VOID *P;


& == ES DAME LA DIRECCION DE MEMORIA DE B A= & B 

Y EL *  DEVUELVE EL DATO QUE ESTA GUARDADO EN DICHA DIRECCCION DE MEMORIA!! TOMA EL DATO DE LA DIRECCION DE MEMORIA REFERENCIADA!!


EL * ES DE INDIRECCION POR QUE NO SE REFIERE A SU PROPIA DIRECCION DE MEMORIA, SINO A LA DIRECCION Q TIENE GUARDADA COMO DATO!!!


C ES IMPRESIONANTE POR QUE SE PUEDE MANIPULAR DIRECTAMENTE LA MEMORIA !!


una direccion de memoria es un numero EN HEXA POR LO CUAL SE PUEDEN USAR OPERADORES RELACIONALES...Y COMPARAR LAS DIRECCIONES DE MEMORIA!!!


NULL ES UNA MACRO IGUAL Q CANT QUE SON NUMEROS!!!


SE PUEDE COMPARAR PUNTEROS CON PUNTEROS, CONTRA NULL Y CON LA DIRECCION DE MEMORIA DE UNA VARIABLE Y TMB SI UN PUNTERO ES IGUAL A UNA DIRECCION DE MEMORIA EXPLICITA...!!!!


NO SE USA LA X NI LA %

LA ARITMETICA DE PUNTEROS ES PARA MOVERSE SOBRE LA DIRECCION DE MEMORIA A LA Q APUNTA LA VARIABLE PUNTERO!!!

LA ARITMETICA DEL PUNTERO SIRVE PARA RECORRER LA MEMORIA!!!!

EL PUNTERO TE QUEDA IGUAL EN DONDE ESTA Y VOS PODES RECORRER LA MEMORIA CON LA ARITMETICA!!


SI HACES ++ EN INT SE DESPLAZA NO UNA DIRECCION DE MEMORIA SINO SE DESPLAZA 4 POR Q ES EL TIPO DE DATO...



ES IGUAL TRABAJAR UN PUNTERO Y UN ARRAY POR QUE TIENEN LAS MISMAS CARACTERISTICAS!!! NO ES Q SEAN IGUALES!

*******SIZEOF DEVUELVE LA CANTIDAD DE BITES Q OCUPA UN TIPO DE DATO, NO ES UNA FUNCION, ES UN OPERADOR FINAL....LOGRA OBTENER LA CANTIDAD DE BYTES Q OCUPA UN TIPO DE DATO O VARIABLE!!!!


*(P+4) 4 ES X Q HACE SIZEOF DE CHAR

SE PUEDE TRABAJAR AL PUNTERO COMO UN ARRAY Y EL ARRAY COMO UN PUNTERO!!

EN EL APUNTE ESTA MAL, PARA QUE INICIE EN 0 ES & ARRAY[O] O ARRAY...SIN EL & ADELANTE!

EN LA PAG 7 ES PUNTERO INT




************************************* EJEMPLO PUNTEROS ***************************************


#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a, *b, *c, x, vec[5], *ptr, i;

    a=15;
    x=a; //copia (tiene 15)
    b = &a; // le asigna la direccion de memoria de a
    c = b; // el dato que tiene el puntero b se le asigna a c, el dato b tiene la dir de memoria de a

    printf("a: %d\nb: %d\nc: %d\nx: %d\n", a, *b, *c, x);

    *b = 13; // se la asigna 13 al dato q esta en la direccion de memoria q guarda el puntero b, a a

    printf("a: %d\nb: %d\nc: %d\nx: %d\n", a, *b, *c, x); // con asterisco es indireccion a la dir de memoria..

    ptr = vec; // le asigna la direccion de memoria del primer elemento del vec a ptr!!! PARA Q ESTO PASE TIENE Q SER VEC (A SECAS ES IGUAL &VEC[O])

    for(i=0; i<5; i++){
        *(ptr+i) = (i+5); // ACA ES ARITMETICA DEL PUNTERO, PARA CARGAR EL ARRAY
    }

    for(i=0; i<5; i++){
        printf("%d\n", *(ptr+i));
    }


    return 0;
}

(EJ EN FOTOS CELU!)


OJOOOOOOOO!

LA FORMULA DE SIZEOF  POSICION DE MEMORIA + NRO POSICION X SIZEOF(INT) ES LA REGLA IMPLICITA QUE SIGUE LA MEMORIA PARA PASAR DE DIRECCION EN DIRECCION....

SE REPITE SIEMPRE IMPLICITAMENTE LO DEL SIZE OF OJOOO!!!









