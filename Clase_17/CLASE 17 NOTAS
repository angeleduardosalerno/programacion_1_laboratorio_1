CLASE 17 ***MEMORIA DINAMICA****


LA PRIMERA VENTAJA DE PUNTEROS ES Q SE PUEDE MODIFICAR POR REFERENCIA LAS FUNCIONES!!

LA SEGUNDA ES OTORGAR MEMORIA DINAMICAMENTE Y EVITAR ASIGNAR MEMORIA ESTATICA!!!
GENERA MAYOR EFICACIA EN LOS RECURSOS!!!

SI HACES UN VECTOR DE 100 NO PODES MODIFICAR AUTOMATICAMENTE SI HAY 101, HAY QUE IR AL CODIGO Y MODIFICARLO,
MEMORIA DINAMICA SIGNIFICA Q CUANDO SE NECESITE ESPACIO SE LA PIDE AUTOMATICAMENTE EN EL TIEMPO DE EJECUCION!!!

STDLIB..........


TODAS LAS FUNCIONES PARA TRABAJAR CON MEMORIA DINAMICA

FUNCION MALLOC. **************************************

SIGNIFICA MEMORY ALOCATION...

RECIBE UN ENTERO Q EQUIVALE A LA CANTIDAD DE BYTES Q ESTOY PIDIENDO.....

DEVUELVE UN PUNTERO VOID VOID* MALLOC OJOOO! O SEA ANTERIORMENTE HAY QUE DECLARAR UN PUNTERO Y Y ASIGNARSELO A MALLOC P=MALLOC

CON PUNTERO A VOID SE PUEDE USAR MALLOC EN CUALQUIER COSA, NO TIENE Q HABER MALLOC DISTINTOS!!!

PARA ESO SE REALIZA EL CASTEO (INT *) MALLOC (SIZEOF(INT O E PERSONA O E JUEGOS --- ACA SE PUEDEN PONER ESTRUCTURAS TAMBIEN!!)*2)

MALLOC DEVUELVE UN PUNTERO QUE GUARDA UN A DIR DE MEMORIA, DEVUELVE LA DIRECCION DE MEMORIA DEL COMIENZO DEL ENTERO.....******OJOO

EJ MALLOC(SIZEOF()*2) ---------> DEVUELVE EL COMIENZO DE DIRECCION DE MEMORIA DEL 2

SINO HAY MEMORIA DISPONIBLE MALLOC DEVUELVE NULL!!! NULL ES UNA CONSTANTE, QUE SIGNIFICA NULO, ES UNA DIRECCION DE MEMORIA QUE NO ES TAL, SIGNIFICA QUE NO ESTA APUNTANDO A NINGUNA DIMENSION DE MEMORIA DE LA MAQUINA!!!!


MALLOC SIRVE PARA PEIR MEMORIA, PERO NO SIRVE PARA REDIMENSIONAR!! HAY QUE COMPLEMENTARLA USANDO REALLOC**************************************

VOID* REALLOC (*PTR, INT)


MALLOC DEVUELVE UN PUNTERO QUE GUARDA UN A DIR DE MEMORIA, DEVUELVE LA DIRECCION DE MEMORIA DEL COMIENZO DEL ENTERO..... 

AL USAR MALLOC Y REALLOC HAY Q USAR *P Y *PAUX


SE USA P EN MALLOC Y REALLOC P AUX ------> P=MALLOC  //// PAUX=REALLOC          ----------------OJOOOOO!

HAY QUE HACERLO ASI PARA Q FUNCIONE OK, SINO DEVUELVE NULL A P, 

VER APUNTES!!!

NO PISA LOS DATOS YA QUE LO UNICO QUE SE HACE ES PEDIR MEMORIA!!!

YA QUE EL PUNTERO TIENE SOLO UNA DIRECCION DE MEMORIA!!!

EL SO TE DA MEMORIA LIBRE, PERO NO LIMPIA, QUEDAN LOS DATOS ANTERIORES!!!
POR ESO HAY QUE INICIALIZAR LAS VARIABLES: CONTADORES Y ACUMULADORES!

CUANDO TE DA MEMORIA EL BLOQUE TIENE Q SER CONSECUTIUVO YA Q TE MOVER X ARITMETICA DE PUNTEROS!!!

X ESO TE TIENE Q DAR EL BLOQUE DE MEMORIA CONSECUTIVO!!

ACORDARSE Q REALOC EMPIEZA LA RESERVA DE MEMORIA CON EL PUNTERO Q SE LE PASA COMO PARAMETRO!!!

EN REALLOC SE MUEVEN TAMBIEN LOS DATOS GUARDADOS EN LA DIRECCION DE MEMORIA!!!!

REALLOC SIRVE PARA AGRANDAR Y PARA LIBERAR EL ESPACIO DE MEMORIA...

PARA LIBERAR LA MEMORIA SE USA FREE FREE(P);*********************PARA LIBERAR LA MEMORIA!!!


ESTUDIAR TEORIA DE LO Q HACE CADA SECTOR DE MEMORIA PAG 3 DEL APUNTE!!


CALLOC****************************************************************************************

NO SE USA MUCHO.......

LA UNICA DIFERENCIA ES Q CALLOC INICIALIZA A 0 EL CONTENIDO DEL ARRAY!!! EL C DE CALLOC HACE REFERENCIA A LA INICIALIZACION EN 0!!



Por ello, antes de usar un puntero devuelto por la función malloc() o por cualquier otra función
de reserva dinámica de memoria es imprescindible, con el fin de evitar posibles fallos en la
ejecución del programa, comprobar que dicho puntero no es nulo (NULL).

int *a;
a=(int *)malloc(sizeof(int));
if (a == NULL)
{
printf("NO QUEDA MEMORIA");
}


FUNCION FREE *****************************************************************************************

SI EL PUNTERO APUNTA A NULL GENERA UN ERROR, POR ESO HAY QUE ASEGURARSE DE Q EL PUNTERO SEA != NULL...
SINO LA APLICACION DEJA DE FUNCIONAR!!!

Y NO SE PUEDE LIBERAR 2 VECES LA MISMA DIRECCION DE MEMORIA!!!

UNA VEZ QUE VOS LIBERASTE CON FREE NO SE PUEDE TENER MAS ACCESO A ELLA QUEDA EN LAS MANOS DEL SO....

POR ESO NO SE PUEDE HACER FREE(P) Y ABAJO FREE(P), YA QUE ESA DIRECCION ESTA EN MANOS DEL SO!!!********


LIBERO DE MANERA DINAMICA LO Q SE ASIGNO CON MEMORIA DINAMICA!!!



EJEMPLOOOOOOOOOOOOOOOOO USO DE MALLOCK Y REALOCK TOMADO DE LOS APUNTES!!!!! OJOOOOOO ESTA ARREGLADO!!!


#include <stdio.h>
#include <stdlib.h>

struct persona
{
    char nombre[50];
    int edad;
};

    int main()
    {
    int seguirCargando;
    int i;
    int auxNuevaLogitud;
    int logitudPersonas = 1; // TIENE Q SER 1 POR QUE AL USAR REALOCC SI SE MULTIPLICA POR 0 QUEDA EN 1!!! O SEA SIEMPRE PIDE MEMORIA PARA UNO !!
    struct persona* pArrayPersona;
    struct persona* pAuxPersona;

    // Creamos el array de personas

    pArrayPersona = malloc(sizeof(struct persona)); // NO ESTAS OBLIGADO A CASTEARLO!! ACA PIDE MEMORIA, PIDE MEMORIA PARA UNA PERSONA YA QUE NO LO MULTIPLICA POR NINGUNA CONSTANTE!!

    if (pArrayPersona == NULL)
    {
        printf("\nNo hay lugar en memoria\n");
        exit(0);
    }

    while(1) // ES UN CICLO INFINITO, TIENE Q HABER UN BREAK QUE LO ROMPA!!!
    {
    printf("\nIngrese nombre: "); // CARGA LOS DATOS
    scanf("%s",(pArrayPersona+logitudPersonas-1)->nombre); // ACA SE LE RESTA UNO POR QUE SE HACE EL REALLOCK CON 1...
    printf("\nIngrese edad: ");
    scanf("%d",&((pArrayPersona+logitudPersonas-1)->edad)); // COMO ESTA PASADO POR UNO SE LO TIENEN Q SACAR!!
    printf("\nSi desea cargar otra persona ingrese (1): ");
    scanf("%d",&seguirCargando);

    if(seguirCargando == 1) // CARGA EL SEGUNDO DATO!
    {
    logitudPersonas++; //Incremento el contador de personas ----------> ACA TIENE Q ESTAR PARA Q FUNCIONE OK!!
    // Calculamos el nuevo tamaño del array
    auxNuevaLogitud = sizeof(struct persona) * logitudPersonas; // EL ERROR ESTABA ACA YA QUE TIENE Q ESTAR EL MAS MAS ACA ASII
    // Redimencionamos la lista
    pAuxPersona = realloc( pArrayPersona, auxNuevaLogitud);

    if (pAuxPersona == NULL)

    {
        printf("\nNo hay lugar en memoria\n");
        break;
    }

        pArrayPersona = pAuxPersona;
    }
    else
    {
    break;
    }
    }

    for(i = 0; i < logitudPersonas; i++)
    {
    printf("\nNombre: %s - ",(pArrayPersona+i)->nombre);
    printf("Edad: %d",(pArrayPersona+i)->edad);
    }
    free(pArrayPersona); // Liberamos la memoria
    return 0;
}




CONCEPTO DE ENCAPSULADO:**********************************

SE ACCEDEN A LOS DATOS PRIVADOS EJ (EDAD) A TRAVEZ DE LA FUNCION PUBLICA (SET EDAD)
POR ESO SE USA SET EDAD, SET EDAD ES PUBLICA Y TOMA LA EDAD PRIVADA DE CADA PERSONA, LA CUAL ESTA DEFINIDA COMO PRIVADA!!

ROBUSTEZ DEL SOFTWARE: *****************

1-NO SE USAN VARIABLES GLOBALES: POR QUE ES VISTA DELDE CUALQUIER LUGAR DEL PROGRAMA Y EL CODIGO NO ESTA MODULARIZADO, YA QUE SINO ESTAS UN MONTON DE TIEMPO PARA CORREGIR EL ERROR!!

2-NO SE ACCEDE AL DATO DE MANERA DIRECTA, HAY CAMPOS PRIVADOS Q SE ACCEDEN POR FUNCIONES SET EDAD
EL GET ELEMENT BY ID DE JS , ES UNA FUNCION QUE TE PERMITE OBTENER UN DATO..........!!!! EL ALERT TAMBIEN ES UNA FUNCION!



person_setAge(Person* this, int age)************************

ASI SE TIPEAN LAS FUNCIONES DE AHORA EN ADELANTE LLEVAN ADELANTE EL NOMBRE DE LA ESTRUCTURA Y DESPUES _  PARA IR LLEGANDO A LAS DISTITNTAS FUNCIONES!!!















